import os
import openmc
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image


def remove_previous_results(batches_number: int = None,
                            suffix: str = "") -> None:
    """
    Remove previous simulation results.
    If batches_number is provided, it removes the specific statepoint file.
    Otherwise, it removes all statepoint files.
    It also removes the summary.h5 file.
    """
    summary_path = "summary.h5"
    if os.path.exists(summary_path):
        os.remove(summary_path)

    if batches_number is not None:
        statepoint_path = f"statepoint{suffix}.{batches_number}.h5"
        if os.path.exists(statepoint_path):
            os.remove(statepoint_path)
    else:
        for file in os.listdir('.'):
            if file.startswith('statepoint') and file.endswith('.h5'):
                os.remove(file)

def remove_intermediate_files():
    """
    Remove every statepoint file except the last one and the summary file.
    """
    summary_path = "summary.h5"
    if os.path.exists(summary_path):
        os.remove(summary_path)

    statepoint_files = [f for f in os.listdir('.') if f.startswith('statepoint.') and f.endswith('.h5')]
    statepoint_files.sort()
    for file in statepoint_files[:-1]:
        os.remove(file)

def remove_surface_source_files():
    """
    Remove all surface source files generated by OpenMC.
    """
    for file in os.listdir('.'):
        if file.startswith('surface_source') and file.endswith('.h5'):
            os.remove(file)


def parallelepiped(xmin, xmax, ymin, ymax, zmin, zmax, 
                   surface_id_start=10, boundary_type:str='vacuum'):
    """
    Creates a rectangular parallelepiped region using OpenMC planes.

    Parameters:
        xmin (float): Minimum x-coordinate.
        xmax (float): Maximum x-coordinate.
        ymin (float): Minimum y-coordinate.
        ymax (float): Maximum y-coordinate.
        zmin (float): Minimum z-coordinate.
        zmax (float): Maximum z-coordinate.
        surface_id_start (int, optional): Starting surface ID for the planes (default is 10).

    Returns:
        openmc.Region: The OpenMC region representing the parallelepiped.
    """
    wall_xmin = openmc.XPlane(x0=xmin, surface_id=surface_id_start, boundary_type=boundary_type)
    wall_xmax = openmc.XPlane(x0=xmax, surface_id=surface_id_start+1, boundary_type=boundary_type)
    wall_ymin = openmc.YPlane(y0=ymin, surface_id=surface_id_start+2, boundary_type=boundary_type)
    wall_ymax = openmc.YPlane(y0=ymax, surface_id=surface_id_start+3, boundary_type=boundary_type)
    wall_zmin = openmc.ZPlane(z0=zmin, surface_id=surface_id_start+4, boundary_type=boundary_type)
    wall_zmax = openmc.ZPlane(z0=zmax, surface_id=surface_id_start+5, boundary_type=boundary_type)
    region = +wall_xmin & -wall_xmax & +wall_ymin & -wall_ymax & +wall_zmin & -wall_zmax
    return region

def plot_geometry(
    materials: list,
    plane: str = "xy",
    width: float = 10.0,
    height: float = 10.0,
    origin: tuple = (0, 0, 0),
    pixels: tuple = (600, 600),
    dpi: int = 300,
    color_by: str = 'material',
    prefix: str = "plot",
    suffix: str = "",
    legend_materials: bool = False,
    saving_figure: bool = False
):
    """
    Plots the OpenMC geometry in a specified plane with a material legend.
    """
    # Set up plot object
    plot = openmc.Plot()
    plot.origin = origin
    plot.width = (width, height)
    plot.pixels = pixels
    plot.color_by = color_by
    plot.basis = plane
    plot.filename = f"plot_openmc_{plane}.png"

    # Assign colors to materials
    default_colors = [
        'red', 'green', 'lightblue', 'gray', 'brown',
        'orange', 'purple', 'yellow', 'pink', "darkgray",
        'magenta' , "black" , "darkgreen" , "darkblue", 
        "darkred", "cyan"
    ]
    colors = (default_colors * ((len(materials) + len(default_colors) - 1) // len(default_colors)))[:len(materials)]
    plot.colors = {mat: color for mat, color in zip(materials, colors)}

    # Plane basis and axis values
    if plane == "xy":
        x_vals = np.linspace(origin[0] - width / 2, origin[0] + width / 2, pixels[0])
        y_vals = np.linspace(origin[1] - height / 2, origin[1] + height / 2, pixels[1])
        xlabel, ylabel = "X (cm)", "Y (cm)"
    elif plane == "xz":
        x_vals = np.linspace(origin[0] - width / 2, origin[0] + width / 2, pixels[0])
        y_vals = np.linspace(origin[2] - height / 2, origin[2] + height / 2, pixels[1])
        xlabel, ylabel = "X (cm)", "Z (cm)"
    elif plane == "yz":
        x_vals = np.linspace(origin[1] - width / 2, origin[1] + width / 2, pixels[0])
        y_vals = np.linspace(origin[2] - height / 2, origin[2] + height / 2, pixels[1])
        xlabel, ylabel = "Y (cm)", "Z (cm)"
    else:
        raise ValueError("plane must be 'xy', 'xz', or 'yz'")

    # Export and plot geometry
    openmc.Plots([plot]).export_to_xml()
    openmc.plot_geometry()

    img = Image.open(plot.filename)
    fig, ax = plt.subplots()
    ax.imshow(img)
    ax.set_title(f"OpenMC Geometry Plot - {plane.upper()} Plane")
    ax.grid(True, which='both', color='gray', linestyle='--', linewidth=0.5, alpha=0.5)
    
    # Set axis labels and ticks
    ax.set_xticks(
        np.linspace(0, img.size[0], num=7),
        [f"{x:.2f}" for x in np.linspace(np.min(x_vals), np.max(x_vals), num=7)]
    )
    ax.set_yticks(
        np.linspace(0, img.size[1], num=7),
        [f"{y:.2f}" for y in np.linspace(np.max(y_vals), np.min(y_vals), num=7)]
    )
    ax.set_xlabel(xlabel)
    ax.set_ylabel(ylabel)
    if legend_materials:
        legend_patches = []
        for mat, color in plot.colors.items():
            if hasattr(mat, 'name') and mat.name:
                label = mat.name
            else:
                label = f"Material {mat.id}"
            legend_patches.append(plt.Rectangle((0, 0), 1, 1, color=color, label=label))
        
        plt.legend(handles=legend_patches, bbox_to_anchor=(1.05, 0.5), loc='center left', 
                   borderaxespad=0., title="Materials")
    plt.tight_layout()
    if saving_figure:
        plt.savefig(f"{prefix}_{plane}{suffix}.png", dpi=dpi, bbox_inches='tight')
    os.remove(plot.filename)
    plt.show()


def mesh_tally_dose_plane(
    plane: str = "xy",
    name_mesh_tally: str = "dose_mesh",
    particule_type: str = 'neutron',
    irradiation_geometry: str = 'ISO',
    bin_number: int = 400,
    lower_left = (-50.0, -50.0),
    upper_right = (50.0, 50.0),
    coord_value: float = 0.0,
    thickness: float = 1.0
) -> object:
    """
    Create a mesh tally for dose in the specified plane at a given coordinate value.
    Data source is ICRP 116.
    The unit of the mesh tally is in pSv/cm^2/s.

    Parameters:
        plane (str): Plane to create the mesh tally in ('xy', 'xz', or 'yz').
        name_mesh_tally (str): Name of the tally.
        particule_type (str): Particle type ('neutron' or 'photon').
        irradiation_geometry (str): Irradiation geometry for dose coefficients ('AP', 'PA', 'LLAT', 'RLAT', 'ROT', 'ISO').
        bin_number (int): Number of bins in each direction.
        lower_left (tuple): Lower left corner of the mesh (2D).
        upper_right (tuple): Upper right corner of the mesh (2D).
        coord_value (float): Coordinate value for the orthogonal axis.
        thickness (float): Thickness along the orthogonal axis.

    Returns:
        openmc.Tally: The mesh tally object.
    """
    mesh = openmc.RegularMesh()
    if plane == "xy":
        mesh.dimension = [bin_number, bin_number, 1]
        mesh.lower_left = (lower_left[0], lower_left[1], coord_value - thickness / 2)
        mesh.upper_right = (upper_right[0], upper_right[1], coord_value + thickness / 2)
    elif plane == "xz":
        mesh.dimension = [bin_number, 1, bin_number]
        mesh.lower_left = (lower_left[0], coord_value - thickness / 2, lower_left[1])
        mesh.upper_right = (upper_right[0], coord_value + thickness / 2, upper_right[1])
    elif plane == "yz":
        mesh.dimension = [1, bin_number, bin_number]
        mesh.lower_left = (coord_value - thickness / 2, lower_left[0], lower_left[1])
        mesh.upper_right = (coord_value + thickness / 2, upper_right[0], upper_right[1])
    else:
        raise ValueError("plane must be 'xy', 'xz', or 'yz'")

    if particule_type == 'neutron':
        energy_bins, dose_coeffs = openmc.data.dose_coefficients(particle="neutron", geometry=irradiation_geometry)
        energy_function_filter = openmc.EnergyFunctionFilter(energy_bins, dose_coeffs, interpolation='cubic')
    elif particule_type == 'photon':
        energy_bins, dose_coeffs = openmc.data.dose_coefficients(particle="photon", geometry=irradiation_geometry)
        energy_function_filter = openmc.EnergyFunctionFilter(energy_bins, dose_coeffs, interpolation='cubic')
    else:
        raise ValueError("particule_type must be 'neutron' or 'photon'")

    mesh_filter = openmc.MeshFilter(mesh)
    mesh_tally = openmc.Tally(name=name_mesh_tally)
    particle_filter = openmc.ParticleFilter([particule_type])
    mesh_tally.filters = [mesh_filter, particle_filter, energy_function_filter]
    mesh_tally.scores = ['flux']
    return mesh_tally


def mesh_tally_plane(
    plane: str = "xy",
    name_mesh_tally: str = "flux_mesh",
    particule_type: str = 'neutron',
    bin_number: int = 400,
    lower_left = (-50.0, -50.0),
    upper_right = (50.0, 50.0),
    coord_value: float = 0.0,
    thickness: float = 1.0,
    score: str = 'flux'
) -> object:
    """
    Create a mesh tally in the specified plane at a given coordinate value.

    Parameters:
        plane (str): Plane to create the mesh tally in ('xy', 'xz', or 'yz').
        name_mesh_tally (str): Name of the tally.
        particule_type (str): Particle type.
        bin_number (int): Number of bins in each direction.
        lower_left (tuple): Lower left corner of the mesh (2D).
        upper_right (tuple): Upper right corner of the mesh (2D).
        coord_value (float): Coordinate value for the orthogonal axis.
        thickness (float): Thickness along the orthogonal axis.
        score (str): Tally score (e.g., 'flux', 'current', 'fission', etc.).

    Returns:
        openmc.Tally: The mesh tally object.
    """
    mesh = openmc.RegularMesh()
    if plane == "xy":
        mesh.dimension = [bin_number, bin_number, 1]
        mesh.lower_left = (lower_left[0], lower_left[1], coord_value - thickness / 2)
        mesh.upper_right = (upper_right[0], upper_right[1], coord_value + thickness / 2)
    elif plane == "xz":
        mesh.dimension = [bin_number, 1, bin_number]
        mesh.lower_left = (lower_left[0], coord_value - thickness / 2, lower_left[1])
        mesh.upper_right = (upper_right[0], coord_value + thickness / 2, upper_right[1])
    elif plane == "yz":
        mesh.dimension = [1, bin_number, bin_number]
        mesh.lower_left = (coord_value - thickness / 2, lower_left[0], lower_left[1])
        mesh.upper_right = (coord_value + thickness / 2, upper_right[0], upper_right[1])
    else:
        raise ValueError("plane must be 'xy', 'xz', or 'yz'")

    mesh_filter = openmc.MeshFilter(mesh)
    mesh_tally = openmc.Tally(name=name_mesh_tally)
    if particule_type != 'all':
            particle_filter = openmc.ParticleFilter([particule_type])
            mesh_tally.filters = [mesh_filter, particle_filter]
    else:
        mesh_tally.filters = [mesh_filter]
    mesh_tally.scores = [score]
    return mesh_tally

def get_mesh_volumes(plane: str = "xy", bin_number: int = 400,
                    lower_left = (-50.0, -50.0),
                    upper_right = (50.0, 50.0),
                    coord_value: float = 0.0,
                    thickness: float = 1.0,):
    """
    Get the volumes of the mesh bins in the specified plane.

    Parameters:
        plane (str): Plane to create the mesh in ('xy', 'xz', or 'yz').
        bin_number (int): Number of bins in each direction.
        lower_left (tuple): Lower left corner of the mesh (2D).
        upper_right (tuple): Upper right corner of the mesh (2D).
        coord_value (float): Coordinate value for the orthogonal axis.
        thickness (float): Thickness along the orthogonal axis.

    Returns:
        np.ndarray: Array of volumes for each mesh bin.
    """
    mesh = openmc.RegularMesh()
    if plane == "xy":
        mesh.dimension = [bin_number, bin_number, 1]
        mesh.lower_left = (lower_left[0], lower_left[1], coord_value - thickness / 2)
        mesh.upper_right = (upper_right[0], upper_right[1], coord_value + thickness / 2)
    elif plane == "xz":
        mesh.dimension = [bin_number, 1, bin_number]
        mesh.lower_left = (lower_left[0], coord_value - thickness / 2, lower_left[1])
        mesh.upper_right = (upper_right[0], coord_value + thickness / 2, upper_right[1])
    elif plane == "yz":
        mesh.dimension = [1, bin_number, bin_number]
        mesh.lower_left = (coord_value - thickness / 2, lower_left[0], lower_left[1])
        mesh.upper_right = (coord_value + thickness / 2, upper_right[0], upper_right[1])
    else:
        raise ValueError("plane must be 'xy', 'xz', or 'yz'")
    
    return mesh.volumes[0][0][0]


def estimate_fissions_and_neutrons(reactor_power:float, nu_bar:float, 
                                   fraction_u235:float=0.1975, fraction_u238:float=None):
    if fraction_u238 is None:
        fraction_u238 = 1.0 - fraction_u235

    energy_u235 = 202.5e6 * 1.60218e-19  # J
    energy_u238 = 205.0e6 * 1.60218e-19  # J

    # Weighted average energy per fission
    energy_per_fission = fraction_u235 * energy_u235 + fraction_u238 * energy_u238

    fissions_per_second = reactor_power / energy_per_fission
    neutrons_emitted_per_second = fissions_per_second * nu_bar
    return fissions_per_second, neutrons_emitted_per_second


def reducing_density(material: openmc.Material, factor: int = 10):
    """    
    Reduces the density of a material by a factor chosen.
    This is useful for simulating materials with lower densities in OpenMC.
    """
    material.set_density("g/cm3", material.density/factor)
    return material

class Volume_cell:
    def __init__(self, cell, surface_type=None):
        self.cell = cell
        self.surface_type = surface_type

    def get_volume(self):
        if hasattr(self.cell.region, 'surface') and getattr(self.cell.region.surface, 'type', None) == 'sphere':
            r = self.cell.region.surface.r  # radius in cm
            return (4/3) * np.pi * r**3  # volume in cm^3
        elif hasattr(self.cell, 'volume') and self.cell.volume is not None:
            return self.cell.volume
        else:
            return None

    def get_surface_area(self):
        if hasattr(self.cell.region, 'surface') and getattr(self.cell.region.surface, 'type', None) == 'sphere':
            r = self.cell.region.surface.r  # radius in cm
            return 4 * np.pi * r**2  # surface area in cm^2
        elif hasattr(self.cell, 'surface_area') and self.cell.surface_area is not None:
            return self.cell.surface_area
        else:
            return None

    def get_center(self):
        if hasattr(self.cell.region, 'surface') and getattr(self.cell.region.surface, 'type', None) == 'sphere':
            x0 = getattr(self.cell.region.surface, 'x0', 0.0)
            y0 = getattr(self.cell.region.surface, 'y0', 0.0)
            z0 = getattr(self.cell.region.surface, 'z0', 0.0)
            return (x0, y0, z0)
        return None
    
def create_dose_rate_tally(name: str, particle_type: str, cell: openmc.Cell) -> openmc.Tally:
    """
    Creates a tally to calculate dose in a specific cell for a given particle type.

    Args:
        name: The name for the tally.
        particle_type: The type of particle to score (e.g., 'photon', 'neutron').
        cell: The cell in which to tally the dose.

    Returns:
        An OpenMC Tally object configured for dose calculation.
    """
    tally = openmc.Tally(name=name)
    tally.scores = ['flux']
    energy_bins, dose_coeffs = openmc.data.dose_coefficients(particle=particle_type, geometry='ISO')
    energy_filter = openmc.EnergyFunctionFilter(energy_bins, dose_coeffs, interpolation='cubic')
    cell_filter = openmc.CellFilter(cell)
    tally.filters = [cell_filter, energy_filter]
    return tally
